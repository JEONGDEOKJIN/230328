// 🟦 스프레드 연산자 


let obj = {name : 'soon' , content : '내용'};

// 객체를 변수에 할당
let obj2 = obj;

obj2.name = 'kim' ;
    // 이렇게 바꾸면 > 둘 다 바뀜⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ 
    // '객체' 는 '주소' 를 참조하는 레퍼런스 타입 이기 때문에, 키 값을 변경해도, obj2 를 바꿔도, ⭐⭐ '둘 다 바뀜'⭐⭐. 

console.log(obj);
console.log(obj2);
console.log(obj == obj2) 
    // true 가 뜸 ⭐⭐⭐⭐⭐⭐⭐⭐ 
    // 같은 애! 왜냐면, '주소' 까지 복사 되기 때문에


// 스프레드 연산자를 사용하면 
    // 1) 주소가 다르게 해서, 2) 값이 복사되어 옴 > 3) 주소가 다르기 때문에, 다른 값 할당 가능⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ 
let obj3 = {...obj}
    // '값' 을 복사 해서 > '새로운 객체' 를 만들어줘서 > obj3 에 넣어줌
obj3.name = "kim2";
console.log(obj3)
    // 이렇게 하면, 이것만 바뀌어 있음


// [특징 정리] 
    // 스프레드 연산자를 사용하면, 원본을 유지하고, 작업을 진행할 수 있다. ⭐⭐⭐⭐⭐ 
    // 데이터 베이스에서, 값을 가져와서, 검색기능을 만든다고 가정하면, 
    // 모든 리스트를 갖고 있는 배열은 유지하되, 
    // 검색으로 걸러낸 배열만 사용하고 싶을 때! 
    // 검색 > 1) 원본 배열 유지 2) 검색으로 걸러낸 배열만 쓸 때 
    // '원본 유지' 하면서 써야 할 때 ⭐⭐⭐⭐⭐⭐⭐⭐ 


// 🟦 [옵션 체이닝]
    // 리액트에서 많이 사용할 것 ⭐⭐⭐⭐⭐ 
    // ES11 에서 도입됨. 
    // 객체의 값을 호출할 때, '안정성' 을 유지하면서, 호출 가능 ⭐⭐⭐⭐⭐ 

    // [문법]
        // obj4?.name
        // 객체의 키 앞에 ? 구문을 추가해서 작성 ⭐⭐⭐ 
        // 그러면, 1) name 이라는 '키' 값이 있는지 확인 2) 없으면 > undefined 를 던짐. > 그러면, 오류가 나지 않는다. 
    
    // [실익]
        // 오류가 나지 않게 방지해준다. ⭐⭐⭐⭐⭐⭐ 
        // 리액트에서 많이 사용

    let obj4 = { name : "soon" , content : "내용" }; 

    console.log(obj4?.name);
        // 오류가 나지 않는 이유는 
            // 1) 객체의 키값을 확인하고 
            // 2) 'type 에러가 나지 않게 방지' 해주기 때문
    
    console.log(obj4?.age)
        // undefined 가 나옴 ⭐⭐ 

        
    let obj5 = {
        name : "soon",
        content : {
            age : 1 
        }
    }
    console.log ( obj5.content.key );
    // node.js 환경에서 보여줄 것! 
    // type error 랑 undefined 